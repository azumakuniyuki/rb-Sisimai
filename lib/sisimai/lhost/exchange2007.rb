module Sisimai::Lhost
  # Sisimai::Lhost::Exchange2007 decodes a bounce email which created by Microsoft Exchange Server
  # 2007 https://www.microsoft.com/microsoft-365/exchange/email.
  # Methods in the module are called from only Sisimai::Message.
  module Exchange2007
    class << self
      require 'sisimai/lhost'

      Indicators = Sisimai::Lhost.INDICATORS
      Boundaries = [
        "Original Message Headers",
        "Original message headers:",                # en-US
        "tes de message d'origine :",               # fr-FR/En-tÃªtes de message d'origine
        "Intestazioni originali del messaggio:",    # it-CH
        "Ursprungshuvuden:",                        # sv-SE
      ].freeze
      StartingOf = {
        error:   [" RESOLVER.", " QUEUE."],
        message: [
          "Error Details",
          "Diagnostic information for administrators:",           # en-US
          "Informations de diagnostic pour les administrateurs",  # fr-FR
          "Informazioni di diagnostica per gli amministratori",   # it-CH
          "Diagnostisk information f",                            # sv-SE
        ],
        rhost:   [
          "DSN generated by:",
          "Generating server",        # en-US
          "Serveur de g",             # fr-FR/Serveur de g’Hn’Hration
          "Server di generazione",    # it-CH
          "Genererande server",       # sv-SE
        ]
      }.freeze
      NDRSubject = {
        "SMTPSEND.DNS.NonExistentDomain" => "hostunknown",   # 554 5.4.4 SMTPSEND.DNS.NonExistentDomain
        "SMTPSEND.DNS.MxLoopback"        => "networkerror",  # 554 5.4.4 SMTPSEND.DNS.MxLoopback
        "RESOLVER.ADR.BadPrimary"        => "systemerror",   # 550 5.2.0 RESOLVER.ADR.BadPrimary
        "RESOLVER.ADR.RecipNotFound"     => "userunknown",   # 550 5.1.1 RESOLVER.ADR.RecipNotFound
        "RESOLVER.ADR.RecipientNotFound" => "userunknown",   # 550 5.1.1 RESOLVER.ADR.RecipientNotFound
        "RESOLVER.ADR.ExRecipNotFound"   => "userunknown",   # 550 5.1.1 RESOLVER.ADR.ExRecipNotFound
        "RESOLVER.ADR.RecipLimit"        => "toomanyconn",   # 550 5.5.3 RESOLVER.ADR.RecipLimit
        "RESOLVER.ADR.InvalidInSmtp"     => "systemerror",   # 550 5.1.0 RESOLVER.ADR.InvalidInSmtp
        "RESOLVER.ADR.Ambiguous"         => "systemerror",   # 550 5.1.4 RESOLVER.ADR.Ambiguous, 420 4.2.0 RESOLVER.ADR.Ambiguous
        "RESOLVER.RST.AuthRequired"      => "securityerror", # 550 5.7.1 RESOLVER.RST.AuthRequired
        "RESOLVER.RST.NotAuthorized"     => "rejected",      # 550 5.7.1 RESOLVER.RST.NotAuthorized
        "RESOLVER.RST.RecipSizeLimit"    => "exceedlimit",   # 550 5.2.3 RESOLVER.RST.RecipSizeLimit
        "QUEUE.Expired"                  => "expired",       # 550 4.4.7 QUEUE.Expired
      }.freeze
      MailSender = ["postmaster@outlook.com", ".onmicrosoft.com"].freeze
      EmailTitle = [
        # Subject:            Content-Language:
        "Undeliverable",    # en-US
        "Non_remis_",       # fr-FR
        "Non remis ",       # fr-FR
        "Non recapitabile", # it-CH
        "Olevererbart",     # sv-SE
      ].freeze

      # @abstract Decodes the bounce message from Microsoft Exchange Server 2007
      # @param  [Hash] mhead    Message headers of a bounce email
      # @param  [String] mbody  Message body of a bounce email
      # @return [Hash]          Bounce data list and message/rfc822 part
      # @return [Nil]           it failed to decode or the arguments are missing
      def inquire(mhead, mbody)
        proceedsto  = 0
        proceedsto += 1 if EmailTitle.any? { |a| mhead["subject"].include?(a) }
        proceedsto += 1 if MailSender.any? { |a| mhead["from"].include?(a) }
        proceedsto += 1 if mhead["content-language"]
        return nil if proceedsto < 2

        require "sisimai/rfc1123"
        require "sisimai/smtp/reply"
        require "sisimai/smtp/status"
        dscontents = [Sisimai::Lhost.DELIVERYSTATUS]
        emailparts = Sisimai::RFC5322.part(mbody, Boundaries)
        bodyslices = emailparts[0].split("\n")
        readcursor = 0      # (Integer) Points the current cursor position
        recipients = 0      # (Integer) The number of 'Final-Recipient' header

        while e = bodyslices.shift do
          # Read error messages and delivery status lines from the head of the email to the previous
          # line of the beginning of the original message.
          if readcursor == 0
            # Beginning of the bounce message or delivery status part
            readcursor |= Indicators[:deliverystatus] if StartingOf[:message].any? { |a| e.start_with?(a) }
            next
          end
          next if (readcursor & Indicators[:deliverystatus]) == 0
          next if e == ""

          # Diagnostic information for administrators:
          #
          # Generating server: mta2.neko.example.jp
          #
          # kijitora@example.jp
          # #550 5.1.1 RESOLVER.ADR.RecipNotFound; not found ##
          #
          # Original message headers:
          v = dscontents[-1]

          if e.include?('@') && e.include?(' ') == false
            # kijitora@example.jp
            if v["recipient"] != ""
              # There are multiple recipient addresses in the message body.
              dscontents << Sisimai::Lhost.DELIVERYSTATUS
              v = dscontents[-1]
            end
            v["recipient"] = Sisimai::Address.s3s4(e)
            v["diagnosis"] = ""
            recipients += 1

          else
            # Try to pick the remote hostname and status code, reply code from the error message
            if StartingOf[:rhost].any? { |a| e.start_with?(a) }
              # Generating server: SG2APC01HT234.mail.protection.outlook.com
              # DSN generated by:       NEKONYAAN0022.apcprd01.prod.exchangelabs.com
              cv = Sisimai::RFC1123.find(e)
              v["rhost"] = cv if Sisimai::RFC1123.is_internethost(cv)
            else
              # #550 5.1.1 RESOLVER.ADR.RecipNotFound; not found ##
              # #550 5.2.3 RESOLVER.RST.RecipSizeLimit; message too large for this recipient ##
              cr = Sisimai::SMTP::Reply.find(e)  || ""
              cs = Sisimai::SMTP::Status.find(e) || ""
              if cr != "" || cs != "" || e.include?("Remote Server ")
                # Remote Server returned '550 5.1.1 RESOLVER.ADR.RecipNotFound; not found'
                # 3/09/2016 8:05:56 PM - Remote Server at mydomain.com (10.1.1.3) returned '550 4.4.7 QUEUE.Expired; message expired'
                v["replycode"] = cr
                v["status"]    = cs
                v["diagnosis"] << e << " "
              end
            end
          end
        end

        while recipients == 0
          # Try to pick the recipient address from the following formatted bounce message:
          #   Original Message Details
          #   Created Date:   4/29/2017 11:23:34 PM
          #   Sender Address: neko@example.com
          #   Recipient Address:      kijitora-nyaan@neko.kyoto.example.jp
          #   Subject:        Nyaan?
          p1 = emailparts[0].index("Original Message Details"); break if p1.nil?
          p2 = emailparts[0].index("\nRecipient Address: ");    break if p2.nil?
          p3 = emailparts[0].index("\n", p2 + 20);              break if p3.nil?
          cv = Sisimai::Address.s3s4(emailparts[0][p2 + 20, p3 - p2 - 20])

          break unless Sisimai::Address.is_emailaddress(cv)
          dscontents[0]["recipient"] = cv
          recipients += 1
        end
        return nil unless recipients > 0

        dscontents.each do |e|
          # Tidy up the error message in $e->{'diagnosis'}, Try to detect the bounce reason.
          e["diagnosis"] = Sisimai::String.sweep(e["diagnosis"])

          p0 = -1; StartingOf[:error].each do |r|
            # Try to find the NDR subject string such as "RESOLVER.ADR.RecipientNotFound" from the
            # error message
            p0 = e["diagnosis"].index(r); break if p0.nil? == false
          end
          next if p0.nil?

          # #550 5.1.1 RESOLVER.ADR.RecipNotFound; not found ##
          cv = e["diagnosis"][p0 + 1, e["diagnosis"].index(";") - p0 - 1]
          next if NDRSubject.has_key?(cv) == false
          e["reason"] = NDRSubject[cv]
        end

        return { "ds" => dscontents, "rfc822" => emailparts[1] }
      end
      def description; return 'Microsoft Exchange Server 2007'; end
    end
  end
end

